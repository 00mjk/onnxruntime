#!/usr/bin/env python

# from __future__ import absolute_import
# from __future__ import division
# from __future__ import print_function
# from __future__ import unicode_literals

from collections import defaultdict
import io
import os
import sys
import argparse

#import numpy as np  # type: ignore

import onnxruntime as rt
import onnxruntime.capi.onnxruntime_pybind11_state as rtpy 
from onnxruntime.capi.onnxruntime_pybind11_state import opkernel 
from onnxruntime.capi.onnxruntime_pybind11_state.opkernel import KernelDef 
#from typing import Any, Text, Sequence, Dict, List, Type, Set, Tuple

def format_version_range(v):
    if (v[1] >= 2147483647):
        return str(v[0])+'+'
    else:
        return '['+str(v[0])+', '+str(v[1])+']'    

def format_type_constraints(tc):
#    tcplit = tc.split('[,]')
    counter = 0
    tcstr = ''
    firsttcitem = True
    for tcitem in tc:
        counter += 1
        if (counter > 3):
            counter = 0
            tcstr += ''#<br>'
        if firsttcitem:
            firsttcitem = False
        else:
            tcstr += ', '
        tcstr += tcitem
    return tcstr
def main(args):  # type: (Type[Args]) -> None
    
    with io.open(args.output, 'w', newline='', encoding="utf-8") as fout:
        fout.write('## Supported Operators Data Types\n')
        fout.write(
            "*This file is automatically generated from the\n"
            "            [def files](/onnxruntime/core/providers/cpu/cpu_execution_provider.cc) via [this script](/tools/python/gen_opkernel_doc.py).\n"
            "            Do not modify directly and instead edit operator definitions.*\n")

        # domain -> support level -> name -> [schema]
        index = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))  # type: Dict[Text, Dict[int, Dict[Text, List[OpSchema]]]]
        #idict = dict()
        for op in rtpy.get_all_opkernel_def():
            domain = op.domain
            if (domain == ''):
                domain = 'ai.onnx.ml'
            index[op.provider][domain][op.op_name].append(op)
               
        fout.write('\n')
        for provider, domainmap in sorted(index.items()):
            fout.write('## Operators implemented by '+provider+'\n\n')
            fout.write('|Op Name | OpSet Versions | Parameter | Types  Supported|\n')
            fout.write('|--------|--------------------|-----------|-----------------|\n')
            for domain, namemap in sorted(domainmap.items()):
                fout.write('**Operator Domain:** *'+domain+'*\n')
                for name, ops in sorted(namemap.items()):
                    namefirsttime = True
                    last_version = (0,0)
                    for op in ops: 
                        if (namefirsttime):
                            fout.write('|'+name+'|')
                            namefirsttime = False
                        else:
                            fout.write('| |')
                        if (op.version_range[0] != last_version[0] or op.version_range[1] != last_version[1]):
                            fout.write(format_version_range(op.version_range)+'|')
                            last_version = op.version_range
                        else:
                            fout.write(' | ')    
                        typeindex = defaultdict(list)
                        for tname,tclist in op.type_constraints.items():
                            for c in tclist:
                                typeindex[tname].append(c)
                        firsttname = True        
                        for tname,tclist in sorted(typeindex.items()):    
                            if firsttname:
                                firsttname = False
                            else: 
                                fout.write('| | | ')
                            fout.write(tname+'|'+format_type_constraints(tclist)+'|\n')
                fout.write('| |\n| |\n')

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='ONNX Runtime Operator Documentation Generator')
    parser.add_argument('--output_path', help='output markdown file path', 
                        default=os.path.join(os.path.dirname(os.path.realpath(__file__)), 'OperatorKernel.md')
                       )
    args = parser.parse_args()


    class Args(object):
        output = args.output_path
    main(Args)
